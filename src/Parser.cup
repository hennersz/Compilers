import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:
  public Boolean syntaxErrors = false;

  public void syntax_error(Symbol current_token) {
    report_error("Syntax error at line " + (current_token.left+1) + ", column "
        + current_token.right, null
    );
    syntaxErrors = true;
  }
:}

// Terminals
// Primitives
terminal BOOL, INT, RAT, FLOAT, CHAR;

// Bool operators
terminal NOT, AND, OR;

// Arithmetic operators
terminal PLUS, MINUS, TIMES, DIV, POW;

// Comparisons
terminal LTHAN, LTHANEQ, GTHANEQ, EQUALS, NEQUALS;

// Aggregate keywords
terminal DICT, SEQ, TOP, STR;

// Operations on Aggregate
terminal APPEND, LEN, IN;

// Declarations
terminal TDEF, FDEF, ALIAS;

// IO Functions
terminal READ, PRINT;

// Control flow
terminal IF, ELIF, ELSE, THEN, ENDIF, WHILE, DO, ENDDO, FORALL;

// Return statement
terminal RETURN;

// Literals
terminal BOOLLIT, CHARLIT, INTLIT, RATLIT, FLOATLIT, STRLIT;

// Identifier
terminal ID;

// Other
terminal RANGBR, LPAREN, RPAREN, ASSIGN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, SEMICOL, COL, MAIN, DOT;

// Non Terminals
nonterminal program, begin, main;
nonterminal funcdeclaration, vardeclaration, typedeclaration;
nonterminal type, paramlist, block, value;
nonterminal primarytype, aggregatetype, dict, seq;
nonterminal aggtype, primaryvalue, aggregatevalue, dictvalue, seqvalue; 
nonterminal dictlisthelp, dictlist;
nonterminal expr, exprlist, exprlisthelp, funccall, seqslice, accessalias;
nonterminal accessaggr;

// Precedences
precedence left PLUS, MINUS, TIMES, DIV, AND, OR, APPEND, COMMA;
precedence right POW, IN, ASSIGN;
precedence nonassoc NOT, LTHAN, LTHANEQ, GTHANEQ, RANGBR, EQUALS, NEQUALS;

// Main logic

start with program;

program ::= begin;

//program ::= begin main begin;

begin ::= vardeclaration SEMICOL  begin | ;
// begin ::= funcdeclaration begin 
//    | typedeclaration begin //TODO
//    | vardeclaration begin
//   |
//    ;

// Type declaration
//-----------------------------
typedeclaration ::= ;

// Variable declarations
//-----------------------------
vardeclaration ::= type ID ASSIGN expr 
                 | type ID
                 ; 

type ::= primarytype 
       | aggregatetype
       ;

// This is used because we don't want declarations like
// top x = 5, since we use top only in dict/seq
aggtype ::= type 
          | TOP
          ;

primarytype ::=  BOOL | INT | RAT | FLOAT | CHAR;

aggregatetype ::= dict | seq | STR ;

dict ::= DICT LTHAN aggtype COMMA aggtype RANGBR;

seq ::= SEQ LTHAN aggtype RANGBR;

// Initialiazation of variables
//-----------------------------
primaryvalue ::= BOOLLIT
                | CHARLIT
                | INTLIT
                | RATLIT
                | FLOATLIT
                ;

aggregatevalue ::= dictvalue
                | seqvalue
                | STRLIT
                ;

dictvalue ::= LBRACE dictlist RBRACE;

seqvalue ::=  LBRACK exprlist RBRACK;

dictlisthelp ::= expr COL expr
           | dictlisthelp COMMA expr COL expr
           ;

dictlist ::= dictlisthelp
           | 
           ;
// Expressions
funccall ::= ID LPAREN exprlist RPAREN;

accessaggr ::= accessaggr LBRACK expr RBRACK
             | aggregatevalue
             | ID
             ;

// TODO: Should we include ID[:] to copy the entire seq?
seqslice ::= accessaggr LBRACK expr COL expr RBRACK
           | accessaggr LBRACK expr COL RBRACK
           | accessaggr LBRACK COL expr RBRACK
           | accessaggr
           ;
accessalias ::= expr DOT ID;


exprlist ::= exprlisthelp | ;

exprlisthelp ::= expr
               | exprlisthelp COMMA expr;

expr ::= NOT expr
       | expr AND expr
       | expr OR expr
       | expr PLUS expr
       | expr MINUS expr
       | expr TIMES expr
       | expr DIV expr
       | expr POW expr
       | expr LTHAN expr
       | expr RANGBR expr
       | expr LTHANEQ expr
       | expr GTHANEQ expr
       | expr EQUALS expr
       | expr NEQUALS expr
       | expr APPEND expr
       | LEN LPAREN expr RPAREN
       | expr IN expr
       | MINUS expr
       | LPAREN expr RPAREN
       | funccall
       | seqslice
       | accessalias
       | primaryvalue // Not aggr because it would be ambiguous with seqslice
       ;

